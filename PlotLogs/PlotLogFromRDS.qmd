---
title: "ShowLogs"
format:
  html: 
    code-tools:
      source: true
      toggle: false
      caption: none
server: shiny
editor: visual
author: Carl Fortelius, v0 March 2023
---

## Quarto

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)


```

This piece of software can access and examine log-files generated by the Harmonie-arome, and display results on a shiny interface. Unfortunately rendering the document in rstudio will not work, but executing chunk by chunk inside rstudio does. See the last chunk of code

Here load needed libraries

```{r initialize}
#library(harp)

# List of required packages
required_packages <- c(
"tidyverse",
"XML",
"rvest",
"hms",
"stringr",        
"httr",
"dplyr",
"ggplot2",
"viridis",
"tidyr",
"shiny",
"shinyFiles",
"shinythemes"
)
# Function to check and install missing packages
install_missing_packages <- function(packages) {
  # Get list of installed packages
  installed_packages <- rownames(installed.packages())
  
  # Find missing packages
  missing_packages <- packages[!packages %in% installed_packages]
  
  if (length(missing_packages) > 0) {
    cat("Installing missing packages:", paste(missing_packages, collapse = ", "), "\n")
    
    # Install missing packages
    install.packages(missing_packages, dependencies = TRUE)
    
    cat("Installation complete!\n")
  } else {
    cat("All required packages are already installed.\n")
  }
}

# Run the installation check
install_missing_packages(required_packages)

# Function to load all required packages
load_packages <- function(packages) {
  cat("Loading packages...\n")
  
  for (pkg in packages) {
    if (require(pkg, character.only = TRUE, quietly = TRUE)) {
      cat("✓", pkg, "loaded successfully\n")
    } else {
      cat("✗ Failed to load", pkg, "\n")
    }
  }
  
  cat("Package loading complete!\n")
}

# Load all required packages
load_packages(required_packages)

#library(harp)

#library(shinythemes)

```

Define a function to read one rds-file from path x

```{r}
read_one_file <- function(x) {
      if(str_detect(x, ".rds")){
        tryCatch(
          {
            readRDS(x) 
          },
          error = function(e) {}
        )
      }   
}
```

Define the client side

```{r }
#Define the client side
ui <- fluidPage(
  #theme = shinytheme("darkly"),
  sidebarLayout(
    sidebarPanel(
      fileInput("file",
              label = "", 
              multiple = TRUE,
              accept = c(".rds")
    ),

      textOutput("update_info"),
      
      tabsetPanel(id = "tabset",
        tabPanel("Spectral norms",
            selectInput("spnorms", "Spectral norm", 
            choices = c(NULL))
         ),
         tabPanel("Grid point norms",
            selectInput("gpnorms", "Grid point norm", 
                    choices = c(NULL))
         ), 
         tabPanel("Surface FullPos norms",
            selectInput("fpgpnorms", "FullPos surface norm", 
                    choices = c(NULL))
         ), 
      ), #tabset panel
   
      selectInput("showzero", "Show zero Y", 
                    choices = c("yes","no") ,selected="no"),
    
     # actionButton("go", "Plot"),
 
    ), #sidebarPanel
    mainPanel(
     plotOutput("plot")
    )
  )
)


```

Define the server side

```{r}
# Define the server side
#| context: server
server <- function(input, output,session) {
v <- reactiveValues(doPlot = FALSE,
                    doRead = FALSE)
 observeEvent(input$file, {
    infile <- input$file
    if (is.null(infile)) {
      return(NULL)
    } else {
      numfiles <<- nrow(infile)
    }
    Data <- lapply(input$file$datapath, read_one_file) 

      updateSelectInput(session, "spnorms",
           choices = attr( Data[[1]]$spectral,"names")) # current selection

      updateSelectInput(session, "gpnorms",
           choices = attr( Data[[1]]$gridpoint,"names")) # current selection

      updateSelectInput(session, "fpgpnorms",
           choices = attr( Data[[1]]$fullposgp,"names")) # current selection

#          }

 observeEvent(input$tabset, {   
   output$plot <- renderPlot({
#    if (input$tabset == "Spectral norms" | 
#        input$tabset == "Grid point norms" ){

       if (input$tabset == "Spectral norms") {
        specimen <- "spectral"
        Y <- input$spnorms
        time_index <- "NSTEP"
      } else if (input$tabset == "Grid point norms"){
        specimen <- "gridpoint"
        Y <- input$gpnorms
        time_index <- "NSTEP"
      }  else if (input$tabset == "Surface FullPos norms"){
        specimen <- "fullposgp"
        Y <- input$fpgpnorms
        time_index <- "STEP"
      } 
 
     lista <- lapply(Data, function(x) tibble(id=x$meta$prefix, NSTEP=x[[specimen]][[time_index]], 
                                         NORM=x[[specimen]][[Y]]))
     TOC <- sapply(Data, function(x) paste(x$meta$start,"-",x$meta$end,
                                            " by ", x$meta$by," hours",": ",
                                           basename(x$meta$path), " \n",sep="") )

     # Define color palette without yellow
     #color_palette <- c("#00AFBB", "#E7B800", "#FC4E07", "#F781BF", "#7FBC41", "#B2DF8A", "#C7C7C7", "#E377C2", "#8C564B")
     color_palette <- c("black", "red", "blue", "orange",  "#F781BF", "#7FBC41", "#B2DF8A", "#C7C7C7", "#E377C2", "#8C564B")
     #color_palette <- c("blue", "blue", "blue",  "blue", "blue", "blue", "blue", "blue","red", "red", "red",  "red", "red", "red", "red", "red")
         
     P <- ggplot(bind_rows(lista, .id="df"), aes(NSTEP, NORM, colour=df)) + 
       scale_color_manual(values = color_palette)  +
  geom_line() +
  ylab(Y) + 
  xlab(time_index) +
  ggtitle(paste(TOC,collapse=""))
  
       if (input$showzero =="yes"){
          P<- P + expand_limits(x = 0, y = 0)}

P


#} 
   
#       p <- ggplot() + 
#        geom_line(data = specimen, aes(x = NSTEP, y = .data[[Y]]), 
#                                       colour = linecolour) +
#        ylab(Y) + 
#        ggtitle(paste( input$path,input$prefix,"yyyymmddhh",input$postfix,"\n",
#                  input$start,"-",input$end," by ",input$by," hours", sep=""))

#       P
  }) #RenderPlot
}) # observe event input$tabset
 }) # observe event input$file
  }
```

Run the application. Do this by clicking on the one to the left of the two symbols to execute all chunks above the present, then click on the one to the right to execute and open shiny.

```{r }
# Run the application 
shinyApp(ui = ui, server = server)

```
